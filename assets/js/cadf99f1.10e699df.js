"use strict";(self.webpackChunkautomatiq_docs=self.webpackChunkautomatiq_docs||[]).push([[8456],{44330:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"dockerising","metadata":{"permalink":"/automatiq-docs/blog/dockerising","source":"@site/blog/automation/selenium/java/2024-12-23-dockerising.md","title":"Part 3 - Dockerising Test Suite","description":"A Comprehensive Guide to Containerising Your Testing Framework","date":"2024-12-23T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"Java","permalink":"/automatiq-docs/blog/tags/java","description":"Java tag description"},{"inline":false,"label":"TestNG","permalink":"/automatiq-docs/blog/tags/testng","description":"TestNG tag description"},{"inline":false,"label":"Maven","permalink":"/automatiq-docs/blog/tags/maven","description":"Maven tag description"},{"inline":false,"label":"Docker","permalink":"/automatiq-docs/blog/tags/docker","description":"Docker tag description"},{"inline":false,"label":"OpenJDK","permalink":"/automatiq-docs/blog/tags/openjdk","description":"OpenJDK tag description"}],"readingTime":10.53,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"dockerising","title":"Part 3 - Dockerising Test Suite","authors":["harryvn"],"tags":["selenium","java","testng","maven","docker","openjdk"]},"unlisted":false,"nextItem":{"title":"Part 2 - Packaging Framework","permalink":"/automatiq-docs/blog/packaging"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nA Comprehensive Guide to Containerising Your Testing Framework\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Introduction\\n\\nIn the previous [article](/blog/packaging), we updated few files for packaging the project artefacts to `JAR` files.\\n\\nIn this article, we will add the ability to run the tests in a containerised environment using `Docker`.\\n\\nWhile there are several approaches to containerise the tests using `Docker`, we will be using the `Dockerfile` approach for our project.\\n\\n---\\n\\n## Prerequisites\\n\\nBefore leveraging the extensive capabilities of `Docker` & `Dockerfile`, let\'s ensure we have it set up properly. Follow the official documentation [here](https://docs.docker.com/engine/install/) to install Docker according to your operating system. The primary goal is to showcase Docker\'s versatility without delving into exhaustive details beyond the scope of this discussion.\\n\\n---\\n\\n## Key Features\\n\\n1. `Multi-Stage Build`: Separates build and runtime environments to reduce image size and improve security.\\n\\n2. `Layer Caching Optimisation`: Uses efficient caching mechanisms for faster builds.\\n\\n3. `Security Best Practices`: Employs a non-root user and limited permissions in the runtime stage.\\n\\n4. `Customisable Execution`: Configures runtime environment variables for flexible test execution.\\n\\n---\\n\\n## Dockerfile\\n\\nLet\'s create a `Dockerfile` for the project, this file will consist of a `multi-stage` build process to ensure the application is built efficiently and the final image is lean and production-ready.\\n\\n### Stage 1 Build\\n\\nLet\'s start with the first `build` stage.\\n\\n<Tabs>\\n    <TabItem value=\\"img1\\" label=\\"Step 1\\">\\nBase Image for first Build Stage\\n\\n```Dockerfile\\nFROM maven:3.8.1-openjdk-17-slim AS builder\\n```\\n\\nThe `FROM` command specifies the base image to use for the first build stage. It pulls a lightweight version of the Maven image with OpenJDK 17 to compile the project. The `AS builder` part names this stage `builder` for use in multi-stage Docker builds, typically where application code is compiled and packaged.\\n</TabItem>\\n<TabItem value=\\"metadata1\\" label=\\"Step 2\\">\\nAdd Metadata Labels (Optional)\\n\\n```Dockerfile\\nLABEL maintainer=\\"<Your Name & Email>\\" \\\\\\n      version=\\"<version number>\\" \\\\\\n      description=\\"<Short Description>\\"\\n```\\n\\nThe above `LABEL` adds metadata to the image for documentation and maintenance purposes.\\n\\n</TabItem>\\n\\n<TabItem value=\\"wrkdir1\\" label=\\"Step 3\\">\\nSet Working Directory\\n\\n```Dockerfile\\nWORKDIR /automation\\n```\\n\\nThe `WORKDIR` command specifies the working directory inside the container to `/automation`. All subsequent commands, such as file copies or builds, will be executed within this directory. If the directory doesn\'t exist, it will be created.\\n\\n</TabItem>\\n\\n<TabItem value=\\"caching\\" label=\\"Step 4\\">\\nOptimise Layer Caching\\n\\n```Dockerfile\\nCOPY pom.xml .\\n```\\n\\nThe `COPY` command copies the `pom.xml` file to the working directory of container to leverage Docker\'s layer caching.\\n\\n</TabItem>\\n\\n<TabItem value=\\"deps1\\" label=\\"Step 5\\">\\nDownload Dependencies\\n\\n```Dockerfile\\nRUN mvn dependency:go-offline -B --no-transfer-progress\\n```\\n\\nThe `RUN` command downloads all dependencies to reduce build time in subsequent steps unless there are changes in project source code.\\n\\n</TabItem>\\n\\n<TabItem value=\\"cp1\\" label=\\"Step 6\\">\\nCopy Project Files\\n\\n```Dockerfile\\nCOPY src ./src\\nCOPY test-suites ./test-suites\\nCOPY testng.xml ./testng.xml\\n```\\n\\nThe `COPY` command copies the entire `src` & `test-suites` to the working directory of container. Similarly, it copies the `testng.xml` configuration file to the container. These commands ensure that the source code, test suites, and TestNG configuration are all available within the container for further processing or testing.\\n\\n:::info\\nWe are copying `testng.xml` as well so that if `${testSuite}` is not provided, the tests will still run using the default suite.\\n:::\\n\\n</TabItem>\\n\\n<TabItem value=\\"pkg1\\" label=\\"Step 7\\">\\nPackage the Application\\n\\n```Dockerfile\\nRUN mvn clean package -DskipTests -B --no-transfer-progress \\\\\\n    && rm -rf ~/.m2/repository\\n```\\n\\nThe `RUN` command compiles and packages the application, skipping tests for faster build and cleans up the local Maven repository to reduce image size.\\n\\n</TabItem>\\n\\n</Tabs>\\n\\n---\\n\\n### Stage 2 Build\\n\\nLet\'s start with the second `build` stage.\\n\\n<Tabs>\\n    <TabItem value=\\"img2\\" label=\\"Step 1\\">\\nBase Image for Runtime\\n\\n```Dockerfile\\nFROM bellsoft/liberica-openjdk-alpine:17.0.7-7\\n```\\n\\nThe `FROM` command specifies the base image to use for the second build stage. It pulls an lightweight Alpine-based image of BellSoft\'s Liberica OpenJDK 17.\\n</TabItem>\\n\\n<TabItem value=\\"metadata2\\" label=\\"Step 2\\">\\nAdd Metadata Labels (Optional)\\n\\n```Dockerfile\\nLABEL maintainer=\\"<Your Name & Email>\\" \\\\\\n      version=\\"<version number>\\" \\\\\\n      description=\\"<Short Description>\\"\\n```\\n\\nThe above `LABEL` adds metadata to the image for documentation and maintenance purposes.\\n\\n</TabItem>\\n\\n<TabItem value=\\"nonroot\\" label=\\"Step 3\\">\\nCreate Non-Root User\\n\\n```Dockerfile\\nRUN addgroup -S automation && adduser -S automation -G automation\\n```\\n\\nThe `RUN` command creates a system group named `automation` and adds a system user with the same name as a member of that group. As a security best practice, always create a `non-root` user to ensure the application runs with limited privileges, enhancing the container\'s security.\\n\\n</TabItem>\\n\\n<TabItem value=\\"wrkdir2\\" label=\\"Step 4\\">\\nSet Working Directory\\n\\n```Dockerfile\\nWORKDIR /automation\\n```\\n\\nThe `WORKDIR` command specifies the working directory inside the container to `/automation`. All subsequent commands, such as file copies or builds, will be executed within this directory. If the directory doesn\'t exist, it will be created.\\n\\n</TabItem>\\n\\n<TabItem value=\\"setperms\\" label=\\"Step 5\\">\\nCreate Directories and Set Permissions\\n\\n```Dockerfile\\nRUN mkdir -p /automation/logs /automation/test-output \\\\\\n    && chown -R automation:automation /automation/logs /automation/test-output\\n```\\n\\nThe `RUN` command creates two directories (`logs` and `test-output`) within the `/automation` folder and sets their ownership to the automation user and group. The `-p` flag ensures parent directories are created if they don\'t exist, while `chown -R` recursively assigns ownership permissions, establishing proper access rights for the application to write logs and test results.\\n\\n</TabItem>\\n\\n<TabItem value=\\"cp2\\" label=\\"Step 6\\">\\nCopy Files from Builder Stage\\n\\n```Dockerfile\\nCOPY --from=builder --chown=automation:automation /automation/target/tafs/libs/ ./libs/\\nCOPY --from=builder --chown=automation:automation /automation/test-suites/ ./test-suites/\\nCOPY --from=builder --chown=automation:automation /automation/testng.xml ./testng.xml\\n```\\n\\nThese `COPY` commands transfer specific files and directories from the `builder` stage to the current stage in the Docker image. The first command copies the application libraries, the second copies test suites and the third copies the TestNG configuration file. By using `--chown=automation:automation`, all copied files are immediately assigned to the automation user and group, ensuring proper access permissions for the application to execute tests.\\n\\n</TabItem>\\n\\n<TabItem value=\\"envar\\" label=\\"Step 7\\">\\nDefine Environment Variables (Optional)\\n\\n```bash\\nENV ENVIRONMENT=REMOTE \\\\\\n    BROWSER=CHROME \\\\\\n    GRID_URL=http://<selenium-grid-host-or-ip>:<port> \\\\\\n    RECORD_VIDEO=false \\\\\\n    HEADLESS=false \\\\\\n    TEST_SUITE=Master.xml\\n```\\n\\nThe `ENV` configuration sets default environment variables for running Selenium tests in a remote environment. It specifies the `browser` to be used as `Chrome`, the `Selenium Grid URL` for remote execution, and toggles options like `video recording` and `headless mode`. The `test suite` to execute is defined as `Master.xml`. This setup ensures flexibility and control over test execution parameters.\\n\\n</TabItem>\\n\\n<TabItem value=\\"entrypoint\\" label=\\"Step 8\\">\\nSet the Entry Point\\n\\n```bash\\nENTRYPOINT [\\"sh\\", \\"-c\\", \\"java -cp \'libs/*\' -Denv=${ENVIRONMENT} \\\\\\n    -Dbrowser=${BROWSER} \\\\\\n    -DremoteSeleniumGridUrl=${GRID_URL} \\\\\\n    -DrecordVideo=${RECORD_VIDEO} \\\\\\n    -Dheadless=${HEADLESS} \\\\\\n    org.testng.TestNG test-suites/${TEST_SUITE}\\"]\\n```\\n\\nThe `ENTRYPOINT` command sets the entry point for the container, specifying the command that runs when the container starts. It executes a Java command to run TestNG, specifying the classpath (`libs/*`), environment variables (like `${ENVIRONMENT}`, `${BROWSER}`, and others), and the test suite to execute from the `test-suites/` directory. This allows dynamic configuration of the test environment using variables passed at runtime.\\n\\n</TabItem>\\n\\n</Tabs>\\n\\n---\\n\\n:::info\\nBelow is the final Dockerfile that uses multi-stage builds with Maven and OpenJDK to ensure an optimised and secure environment for running test suites.\\n:::\\n\\n```dockerfile\\n# Use the Maven image to compile the project\\nFROM maven:3.8.1-openjdk-17-slim AS builder\\n\\n# Add metadata labels\\nLABEL maintainer=\\"<Your Name & Email>\\" \\\\\\n      version=\\"<version number>\\" \\\\\\n      description=\\"<Short Description>\\"\\n\\n# Set the working directory\\nWORKDIR /automation\\n\\n# Optimize layer caching by copying only pom.xml first\\nCOPY pom.xml .\\n\\n# Use specific maven goals and options for better performance\\nRUN mvn dependency:go-offline -B --no-transfer-progress\\n\\n# Copy necessary project files\\nCOPY src ./src\\nCOPY test-suites ./test-suites\\nCOPY testng.xml ./testng.xml\\n\\n# Package the application\\nRUN mvn clean package -DskipTests -B --no-transfer-progress && rm -rf ~/.m2/repository\\n\\n# Use an openjdk image from bellsoft\\nFROM bellsoft/liberica-openjdk-alpine:17.0.7-7\\n\\n# Add metadata labels\\nLABEL maintainer=\\"<Your Name & Email>\\" \\\\\\n      version=\\"<version number>\\" \\\\\\n      description=\\"<Short Description>\\"\\n\\n# Create non-root user for security\\nRUN addgroup -S automation && adduser -S automation -G automation\\n\\n# Set the working directory\\nWORKDIR /automation\\n\\n# Create logs and test-output directories and set permissions\\nRUN mkdir -p /automation/logs /automation/test-output && chown -R automation:automation /automation/logs /automation/test-output\\n\\n# Copy only required files from builder stage\\nCOPY --from=builder --chown=automation:automation /automation/target/tafs/libs/ ./libs/\\nCOPY --from=builder --chown=automation:automation /automation/test-suites/ ./test-suites/\\nCOPY --from=builder --chown=automation:automation /automation/testng.xml ./testng.xml\\n\\n# Define environment variables with defaults\\nENV ENVIRONMENT=REMOTE \\\\\\n    BROWSER=CHROME \\\\\\n    GRID_URL=http://<selenium-grid-host-or-ip>:<port> \\\\\\n    RECORD_VIDEO=false \\\\\\n    HEADLESS=false \\\\\\n    TEST_SUITE=Master.xml\\n\\n# Set the entry point\\nENTRYPOINT [\\"sh\\", \\"-c\\", \\"java -cp \'libs/*\' -Denv=${ENVIRONMENT} -Dbrowser=${BROWSER} -DremoteSeleniumGridUrl=${GRID_URL} -DrecordVideo=${RECORD_VIDEO} -Dheadless=${HEADLESS} org.testng.TestNG test-suites/${TEST_SUITE}\\"]\\n```\\n\\n---\\n\\n## Environment Variables\\n\\n| Variable       | Value                                      | Description                               |\\n| -------------- | ------------------------------------------ | ----------------------------------------- |\\n| `ENVIRONMENT`  | `REMOTE `                                  | Test environment (e.g., LOCAL or REMOTE). |\\n| `BROWSER`      | `CHROME`                                   | Browser for test execution.               |\\n| `GRID_URL`     | `http://<selenium-grid-host-or-ip>:<port>` | Selenium Grid URL for remote execution.   |\\n| `RECORD_VIDEO` | `false`                                    | Enable/disable video recording.           |\\n| `HEADLESS`     | `false`                                    | Run browser in headless mode.             |\\n| `TEST_SUITE`   | `Master.xml`                               | TestNG suite file to execute.             |\\n\\n---\\n\\n## Directory Structure\\n\\nThe container maintains the following structure:\\n\\n```bash\\n/automation/\\n\u251c\u2500\u2500 libs/          # Application dependencies\\n\u251c\u2500\u2500 test-suites/   # TestNG suite files\\n\u251c\u2500\u2500 testng.xml     # TestNG configuration\\n\u251c\u2500\u2500 logs/          # Test execution logs\\n\u2514\u2500\u2500 test-output/   # Test results and reports\\n```\\n\\n---\\n\\n## Build Docker Image\\n\\nNext, to run the tests inside the container, we need to build the Docker image first.\\n\\nLet\'s run the following command to build the Docker image.\\n\\n```bash\\ndocker build -t tafs-automation:1.0 .\\n```\\n\\nThe above command builds a Docker image from the Dockerfile located in the current directory (`.`). The `-t `flag tags the image with the name `tafs-automation` and assigns the version `1.0`, making it easier to reference and manage the image later.\\n\\nBelow is the command in action.\\n\\n<img src={require(\'@site/static/img/java/build.avif\').default} alt=\\"build\\" />\\n\\n<br/><br/>\\n\\n:::info\\nRun command `docker image ls` to confirm the image is built successfully.\\n:::\\n\\n<img src={require(\'@site/static/img/java/docker-image.avif\').default} alt=\\"dkrimg\\" />\\n\\n---\\n\\n## Run Tests\\n\\nWe are all set to execute the tests inside Docker container using the image we built in previous step.\\n\\n```bash\\ndocker run -d --rm --name tafs -e ENVIRONMENT=REMOTE -e BROWSER=CHROME -e GRID_URL=http://<selenium-grid-host-or-ip>:<port> -e RECORD_VIDEO=false -e HEADLESS=false -e TEST_SUITE=LoginPage.xml tafs-automation:1.0\\n```\\n\\nThe above command launches a new container named `tafs` from the `tafs-automation:1.0` image. The `-d` flag ensures the container starts in detached mode and `--rm` flag ensures the container is automatically removed after it stops running. Various environment variables are passed using flag `-e` to configure the test execution: `ENVIRONMENT` is set to `REMOTE`, `BROWSER` to `CHROME`, `GRID_URL` to `http://<selenium-grid-host-or-ip>:<port>`, and options for video recording and headless mode are specified as `false`. Finally, `TEST_SUITE` is set to `LoginPage.xml`, indicating which test suite to execute.\\n\\n:::info\\nRun command `docker container ls -a` to confirm the container is up and running.\\n:::\\n\\n<img src={require(\'@site/static/img/java/docker-container.avif\').default} alt=\\"docker-container\\" />\\n\\n<br/><br/>\\n\\n<img src={require(\'@site/static/img/java/live-preview.avif\').default} alt=\\"live-preview\\" />\\n\\n<br/><br/>\\n\\n:::info\\nTo configure a Selenium Grid on your system to execute automation scripts, please refer to this [section](/blog/docker) of my another article, which demonstrates how to set up a Selenium Grid on local or remote systems.\\n:::\\n\\n---\\n\\n## Conclusion\\n\\nIn this article, we have effectively incorporated Docker into our testing workflow by developing a Dockerfile and building a Docker image. This method enables us to execute tests in a containerised environment, ensuring consistency and reliability across various systems. By following the steps detailed, we have produced a lightweight and production-ready Docker image capable of running our test suites with multiple configurations. This setup not only simplifies our testing process but also improves scalability and maintainability, making it more manageable to execute tests across different environments.\\n\\nThe source code is available on [GitHub](https://github.com/harryvn/selenium-automation-framework-java). If you find the framework helpful, be sure to star the repository to show your support!\\n\\nIn the next `article`, we will advance the project by introducing `Jenkins` CI/CD tool to configure various stages of the Docker process, including executing automation scripts as part of the pipeline.\\n\\nIf you find this article helpful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!\\n\\n---\\n\\n## References\\n\\n[Docker](https://docs.docker.com/)\\n\\n[Selenium](https://www.selenium.dev/)\\n\\n[TestNG](https://testng.org/)\\n\\n[Maven](https://maven.apache.org/guides/index.html)\\n\\n[OpenJDK](https://openjdk.org/)"},{"id":"packaging","metadata":{"permalink":"/automatiq-docs/blog/packaging","source":"@site/blog/automation/selenium/java/2024-08-10-packaging.md","title":"Part 2 - Packaging Framework","description":"A step-by-step guide on creating reusable and portable automation packages.","date":"2024-08-10T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"Java","permalink":"/automatiq-docs/blog/tags/java","description":"Java tag description"},{"inline":false,"label":"TestNG","permalink":"/automatiq-docs/blog/tags/testng","description":"TestNG tag description"},{"inline":false,"label":"Maven","permalink":"/automatiq-docs/blog/tags/maven","description":"Maven tag description"}],"readingTime":8.03,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"packaging","title":"Part 2 - Packaging Framework","authors":["harryvn"],"tags":["selenium","java","testng","maven"]},"unlisted":false,"prevItem":{"title":"Part 3 - Dockerising Test Suite","permalink":"/automatiq-docs/blog/dockerising"},"nextItem":{"title":"Part 1 - Selenium Automation Framework in Java","permalink":"/automatiq-docs/blog/selenium-framework-java"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nA step-by-step guide on creating reusable and portable automation packages.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Introduction\\n\\nIn the previous [article](/blog/selenium-framework-java), we created a modular automation testing framework using Selenium WebDriver, TestNG, Java, and Maven.\\n\\nIn this article, we will add support for packaging the entire project to a `JAR` file as a prerequisite for running the tests in a containerised environment using Docker.\\n\\n---\\n\\n## Update `pom.xml` file\\n\\nTo ensure the tests can run inside a Docker container, we need to modify the `pom.xml` file of the project. The first step involves specifying a new directory for our test artefacts to include a `<package.directory>` property. This will direct Maven to place the packaged test artefacts in a specific directory within the build output.\\n\\nHere\u2019s how to update the `pom.xml`.\\n\\n<Tabs>\\n    <TabItem value=\\"porperties\\" label=\\"Step 1\\">\\nAdd the following to `<properties>` tag.\\n\\n```xml\\n<properties>\\n    <package.directory>${project.build.directory}/tafs</package.directory>\\n    <testSuite>testng.xml</testSuite>\\n</properties>\\n```\\n\\nThese properties define directories and configurations for a Maven project. The `<package.directory>` specifies where to place generated files. The `testSuite` property identifies the TestNG XML file to use for testing. These settings help manage build outputs and testing configurations within the project\'s build lifecycle.\\n</TabItem>\\n<TabItem value=\\"build\\" label=\\"Step 2\\">\\nAdd name under `<build>` tag.\\n\\n```xml\\n<build>\\n    <finalName>tafs</finalName>\\n</build>\\n```\\n\\nThe `<finalName>tafs</finalName>` configuration in Maven specifies the final name of the packaged output (typically a JAR or WAR file) when the project is built. In the context of the previous properties, where directories like `<package.directory>` and others are defined, `<finalName>tafs</finalName>` ensures that the resulting artefact (like `tafs.jar` or `tafs.war`) is named consistently with these settings. This helps in organising and identifying the built artefact within the specified output directories `${project.build.directory}/tafs` during the Maven build process.\\n\\n:::info\\nIn this context, `<fileName>` can be any name.\\n:::\\n</TabItem>\\n\\n<TabItem value=\\"testsuite\\" label=\\"Step 3\\">\\nUpdate `<testSuite>` property.\\n\\n```xml\\n<plugin>\\n    <artifactId>maven-surefire-plugin</artifactId>\\n    <version>2.22.1</version>\\n    <configuration>\\n        <suiteXmlFiles>\\n            <suiteXmlFile>${testSuite}</suiteXmlFile>\\n        </suiteXmlFiles>\\n    </configuration>\\n</plugin>\\n```\\n\\nThe `<suiteXmlFiles>` section with `<suiteXmlFile>${testSuite}</suiteXmlFile>` points to the TestNG XML file that is specified by `${testSuite}` from the project properties.\\n</TabItem>\\n<TabItem value=\\"depsplugin\\" label=\\"Step 4\\">\\nAdd `maven-dependency-plugin`\\n\\n```xml\\n<plugin>\\n    <groupId>org.apache.maven.plugins</groupId>\\n    <artifactId>maven-dependency-plugin</artifactId>\\n    <version>3.6.1</version>\\n    <executions>\\n        <execution>\\n            <id>copy-dependencies</id>\\n            <phase>prepare-package</phase>\\n            <goals>\\n                <goal>copy-dependencies</goal>\\n            </goals>\\n            <configuration>\\n                <outputDirectory>${package.directory}/libs</outputDirectory>\\n            </configuration>\\n        </execution>\\n    </executions>\\n</plugin>\\n```\\n\\nThe above `plugin` ensures that all project dependencies are gathered and copied to a designated location `${package.directory}/libs` before the final packaging. This process supports a clean and organised build, where dependencies are readily available for packaging and testing workflows defined in the Maven project.\\n\\n</TabItem>\\n<TabItem value=\\"mvnplugin\\" label=\\"Step 5\\">\\nUpdate `maven-jar-plugin`\\n\\n```xml\\n<plugin>\\n    <artifactId>maven-jar-plugin</artifactId>\\n    <version>3.0.2</version>\\n    <configuration>\\n        <outputDirectory>${package.directory}/libs</outputDirectory>\\n    </configuration>\\n    <executions>\\n        <execution>\\n            <goals>\\n                <goal>test-jar</goal>\\n            </goals>\\n        </execution>\\n    </executions>\\n</plugin>\\n```\\n\\nThis configuration helps automate the packaging of test classes and resources into a separate JAR file. By setting the `outputDirectory` to `${package.directory}/libs`, the resulting JAR is organised into a specific location, aligning with the overall project build structure. This is particularly useful for projects that require separate distribution or testing of compiled test classes, supporting a streamlined and organised build process.\\n\\n</TabItem>\\n<TabItem value=\\"resplugin\\" label=\\"Step 6\\">\\nAdd `maven-resources-plugin`\\n\\n```xml\\n<plugin>\\n    <groupId>org.apache.maven.plugins</groupId>\\n    <artifactId>maven-resources-plugin</artifactId>\\n    <version>3.2.0</version>\\n    <executions>\\n        <execution>\\n            <id>copy-resources-to-docker</id>\\n            <phase>prepare-package</phase>\\n            <goals>\\n                <goal>copy-resources</goal>\\n            </goals>\\n            <configuration>\\n                <outputDirectory>${package.directory}/test-suites</outputDirectory>\\n                <resources>\\n                    <resource>\\n                        <directory>test-suites</directory>\\n                    </resource>\\n                </resources>\\n            </configuration>\\n        </execution>\\n    </executions>\\n</plugin>\\n```\\n\\nThe above configuration copy resources from the `test-suites` directory to `${package.directory}/test-suites` during the `prepare-package` phase. This setup promotes an organised build structure, ensuring that all required files are bundled correctly in the build output, which streamlines the build process and facilitates smoother packaging, deployment, and testing workflows.\\n\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n## Creating Test Suites\\n\\nSo far, there is only a single `testng.xml` file in the project root and while test execution it will run all the tests either in parallel or sequentially based on the `parallel` property.\\n\\nHowever, the tests will evolve as we add more test cases to our project, at some point it might get difficult to maintain a single `xml` file for all the test cases. To handle this, we will create a separate `xml` file for each test suite, it will modulate the test execution based on the `suite` property.\\n\\nLet\'s create a `test-suites` directory in project root and add the xml files in it.\\n\\n```bash\\n.\\n\u2514\u2500\u2500 test-suites\\n    \u251c\u2500\u2500 HomePage.xml\\n    \u251c\u2500\u2500 LoginPage.xml\\n    \u2514\u2500\u2500 Master.xml\\n```\\n\\n:::info\\nWith the above structure, we can execute the test suite based on the `suite` property. Also, to note we have added a `Master.xml` file in the `test-suites` directory, this will be used to run all the tests in parallel.\\n:::\\n\\n---\\n\\n## Packaging\\n\\nNow that all the prerequisites are in place, it\'s time to package the project.\\n\\n```bash\\nmvn clean package -DskipTests\\n```\\n\\nThe above command will `clean` the project, `package` it into a `JAR` file, and `skip` the test execution phase to speed up the build process.\\n\\n<img src={require(\'@site/static/img/java/packaging.avif\').default} alt=\\"packaging\\" />\\n\\n---\\n\\n## Target Directory Structure\\n\\nAfter the previous command executes successfully, the `target` directory structure will appear as follows.\\n\\n```bash\\n\u2502\\n\u251c\u2500\u2500 target\\n\u2502   \u251c\u2500\u2500 classes\\n\u2502   \u251c\u2500\u2500 generated-sources\\n\u2502   \u251c\u2500\u2500 generated-test-sources\\n\u2502   \u251c\u2500\u2500 maven-archiver\\n\u2502   \u251c\u2500\u2500 maven-status\\n\u2502   \u251c\u2500\u2500 tafs\\n\u2502   \u2502   \u251c\u2500\u2500 libs\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 async-http-client-2.12.3.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 async-http-client-netty-utils-2.12.3.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auto-service-annotations-1.1.1.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 byte-buddy-1.14.5.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 checker-qual-3.33.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 commons-exec-1.3.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 commons-io-2.16.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 error_prone_annotations-2.18.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 extentreports-5.1.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 failsafe-3.3.2.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 failureaccess-1.0.1.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 freemarker-2.3.32.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 gson-2.10.1.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 guava-32.1.2-jre.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 j2objc-annotations-2.8.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 jakarta.activation-1.2.2.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 jcommander-1.82.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 jquery-3.6.1.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 jsr305-3.0.2.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 log4j-api-2.20.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 log4j-core-2.20.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 lombok-1.18.26.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-buffer-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-codec-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-codec-http-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-codec-socks-4.1.60.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-common-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-handler-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-handler-proxy-4.1.60.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-reactive-streams-2.0.4.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-resolver-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-classes-epoll-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-classes-kqueue-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-native-epoll-4.1.60.Final-linux-x86_64.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-native-epoll-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-native-kqueue-4.1.60.Final-osx-x86_64.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-native-kqueue-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 netty-transport-native-unix-common-4.1.96.Final.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-api-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-api-events-1.28.0-alpha.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-context-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-exporter-logging-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-extension-incubator-1.28.0-alpha.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-common-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-extension-autoconfigure-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-extension-autoconfigure-spi-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-logs-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-metrics-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-sdk-trace-1.28.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 opentelemetry-semconv-1.28.0-alpha.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 owner-1.0.12.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 reactive-streams-1.0.4.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 rxjava-3.1.6.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-api-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-chrome-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-chromium-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-devtools-v114-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-devtools-v115-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-devtools-v116-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-devtools-v85-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-edge-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-firefox-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-http-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-ie-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-java-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-json-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-manager-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-os-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-remote-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-safari-driver-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 selenium-support-4.12.0.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 slf4j-api-2.0.9.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 slf4j-simple-2.0.9.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 tafs-tests.jar\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 tafs.jar\\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 testng-7.8.0.jar\\n\u2502   \u2502   \u2514\u2500\u2500 test-suites\\n\u2502   \u2502       \u251c\u2500\u2500 HomePage.xml\\n\u2502   \u2502       \u251c\u2500\u2500 LoginPage.xml\\n\u2502   \u2502       \u2514\u2500\u2500 Master.xml\\n\u2502   \u2514\u2500\u2500 test-classes\\n\u2502\\n```\\n\\nIn this setup, all dependent external `JAR` files will be located in the `target/tafs/libs` directory, and all test suite files will be stored in the `target/tafs/test-suites` directory.\\n\\n:::info\\nThe `target/tafs/libs` directory will also contain two JAR files named `tafs.jar` and `tafs-tests.jar`, which are the packaged project files.\\n:::\\n\\n---\\n\\n## Run Tests\\n\\nAs a best practice, it is recommended to test the build once before proceeding with further steps. From the project root, navigate to the `target/tafs` directory.\\n\\n```bash\\ncd target/tafs\\n```\\n\\nNext, execute the below command to run the tests.\\n\\n```bash\\njava -cp \'libs/*\' org.testng.TestNG test-suites/${testSuite}.xml\\n```\\n\\n:::info\\nHere, replace `${testSuite}` with actual file name (e.g. LoginPage, Master etc.)\\n:::\\n\\n<img src={require(\'@site/static/img/java/run-tests.avif\').default} alt=\\"run-tests\\" />\\n\\n---\\n\\n## Conclusion\\n\\nBy following the steps outlined above, we have successfully updated our project to package it into a `JAR` file, ready for execution in a containerised environment using Docker. This process involved modifying the `pom.xml` file to direct Maven to organise and manage the build outputs effectively. We also introduced separate XML files for different test suites to streamline the test execution process.\\n\\nWith this setup, our automation testing framework is now more modular, organized, and scalable, allowing for easier maintenance and execution of tests in various environments. This approach not only enhances the efficiency of our testing process but also ensures that our test suites are well-structured and manageable as the project grows.\\n\\nThe source code is available on [GitHub](https://github.com/harryvn/selenium-automation-framework-java). If you find the framework helpful, be sure to star the repository to show your support!\\n\\nIn the next [article](/blog/dockerising), we will explore how to leverage the packaged project for execution in `Docker` containers.\\n\\nIf you find this article helpful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!\\n\\n---\\n\\n## References\\n\\n[Selenium](https://www.selenium.dev/)\\n\\n[TestNG](https://testng.org/)\\n\\n[Maven](https://maven.apache.org/guides/index.html)\\n\\n---"},{"id":"selenium-framework-java","metadata":{"permalink":"/automatiq-docs/blog/selenium-framework-java","source":"@site/blog/automation/selenium/java/2024-04-13-framework.md","title":"Part 1 - Selenium Automation Framework in Java","description":"A Selenium-based modular automation framework in Java for web application testing.","date":"2024-04-13T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"Java","permalink":"/automatiq-docs/blog/tags/java","description":"Java tag description"},{"inline":false,"label":"TestNG","permalink":"/automatiq-docs/blog/tags/testng","description":"TestNG tag description"},{"inline":false,"label":"ExtentReports","permalink":"/automatiq-docs/blog/tags/extentreports","description":"ExtentReports tag description"},{"inline":false,"label":"Maven","permalink":"/automatiq-docs/blog/tags/maven","description":"Maven tag description"},{"inline":false,"label":"Log4J","permalink":"/automatiq-docs/blog/tags/log4j","description":"Log4J tag description"}],"readingTime":9.12,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"selenium-framework-java","title":"Part 1 - Selenium Automation Framework in Java","authors":["harryvn"],"tags":["selenium","java","testng","extentreports","maven","log4j"]},"unlisted":false,"prevItem":{"title":"Part 2 - Packaging Framework","permalink":"/automatiq-docs/blog/packaging"},"nextItem":{"title":"Part 3 - Docker Implementation","permalink":"/automatiq-docs/blog/docker"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nA Selenium-based modular automation framework in Java for web application testing.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Github Repository\\n\\n[Java Selenium Automation Framework](https://github.com/harryvn/selenium-automation-framework-java)\\n\\nThe GitHub repository linked above serves as the foundation for our Selenium automation framework project. Inside, you\'ll find a comprehensive Java-based framework designed to streamline web testing and automation tasks.\\n\\nHere\'s what you can expect to find:\\n\\n1. Framework Architecture: Dive into the src directory to explore the architecture of our Selenium automation framework. The framework is structured to promote scalability, maintainability, and reusability of test scripts and resources.\\n\\n2. Test Scripts: Browse through the test directory to discover a collection of test scripts demonstrating various automation scenarios. These scripts leverage the power of Selenium WebDriver and Java to interact with web elements, perform actions, and validate outcomes.\\n\\n3. Utilities: Explore the utilities package to find utility classes with methods that facilitate common automation tasks, these components aim to streamline your automation workflow.\\n\\nFeel free to clone the repository to explore the source code, experiment with test scripts, or adapt the framework to suit your specific testing needs. Whether you\'re a QA engineer, a software developer, or a curious learner, this repository provides valuable insights into building efficient Selenium automation frameworks with Java.\\n\\n:::note\\nThis project is licensed under the GPL [LICENSE](https://github.com/harryvn/selenium-automation-framework-java/blob/main/LICENSE).\\n:::\\n\\n---\\n\\n## Introduction\\n\\nThis blog post introduces a Selenium-based modular automation framework developed in Java for web application testing. The framework is designed to be scalable, maintainable, and efficient, allowing you to automate tests for your web applications.\\n\\n---\\n\\n## Key Features\\n\\n| Feature                    | Description                                                                                                   |\\n| -------------------------- | ------------------------------------------------------------------------------------------------------------- |\\n| `Modular Design`           | The framework follows a modular architecture, promoting separation of concerns and improving maintainability. |\\n| `Page Object Model (POM)`  | It utilises the Page Object Model pattern for better code organisation and reusability.                       |\\n| `TestNG Integration`       | TestNG is integrated for robust test management, parallel execution, and reporting capabilities.              |\\n| `Logging and Reporting`    | Logging and reporting mechanisms provide detailed insights into test execution.                               |\\n| `Configuration Management` | External configuration files manage test environment configurations.                                          |\\n| `Cross-Browser Testing`    | The framework supports testing across various browsers.                                                       |\\n| `Parallel Execution`       | Test suites can be executed concurrently, reducing execution time.                                            |\\n| `Customisable`             | Framework components are designed to be customisable for specific project requirements.                       |\\n\\n---\\n\\n## Project Insigths\\n\\n<Tabs>\\n    <TabItem value=\\"structure\\" label=\\"Structure\\">\\nThe project structure is well-organised, with clear separation of functionalities. The provided image offers a visual representation of the structure.\\n\\n```bash\\n    .\\n    \u251c\u2500\u2500 logs\\n    \u2502   \u2514\u2500\u2500 automation.log\\n    \u251c\u2500\u2500 pom.xml\\n    \u251c\u2500\u2500 reports\\n    \u2502   \u2514\u2500\u2500 AutomationReport.html\\n    \u251c\u2500\u2500 runTests.sh\\n    \u251c\u2500\u2500 src\\n    \u2502   \u251c\u2500\u2500 main\\n    \u2502   \u2502   \u251c\u2500\u2500 java\\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 com\\n    \u2502   \u2502   \u2502       \u2514\u2500\u2500 example\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 assertions\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 SoftAssertionManager.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 browserCapabilities\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 ChromeCapabilities.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 EdgeCapabilities.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 FirefoxCapabilities.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 browserManager\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 BrowserManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 LocalBrowserManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 RemoteBrowserManager.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 configManager\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 ConfigFactory.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 FMConfig.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 driverManager\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 DriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 LocalChromeDriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 LocalEdgeDriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 LocalFirefoxDriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 RemoteChromeDriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 RemoteEdgeDriverManager.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 RemoteFirefoxDriverManager.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 enums\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 BrowserType.java\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 EnvironmentType.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 LocatorType.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 listeners\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 ExtentTestListener.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 logManager\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 LoggerManager.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 pagefactory\\n    \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 HomePage.java\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 LoginPage.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 reportManager\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 ExtentReportManager.java\\n    \u2502   \u2502   \u2502           \u251c\u2500\u2500 testbuilder\\n    \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 TestBuilder.java\\n    \u2502   \u2502   \u2502           \u2514\u2500\u2500 utilities\\n    \u2502   \u2502   \u2502               \u251c\u2500\u2500 CommonUtil.java\\n    \u2502   \u2502   \u2502               \u251c\u2500\u2500 ExtentReportNGUtil.java\\n    \u2502   \u2502   \u2502               \u2514\u2500\u2500 StarterKit.java\\n    \u2502   \u2502   \u2514\u2500\u2500 resources\\n    \u2502   \u2502       \u251c\u2500\u2500 local.properties\\n    \u2502   \u2502       \u251c\u2500\u2500 log4j2.xml\\n    \u2502   \u2502       \u2514\u2500\u2500 remote.properties\\n    \u2502   \u2514\u2500\u2500 test\\n    \u2502       \u2514\u2500\u2500 java\\n    \u2502           \u2514\u2500\u2500 com\\n    \u2502               \u2514\u2500\u2500 example\\n    \u2502                   \u2514\u2500\u2500 testcases\\n    \u2502                       \u251c\u2500\u2500 HomePageTest.java\\n    \u2502                       \u2514\u2500\u2500 LoginPageTest.java\\n    \u2514\u2500\u2500 testng.xml\\n```\\n\\n    </TabItem>\\n    <TabItem value=\\"pkg\\" label=\\"Packages & Classes\\">\\n\\nBelow are the packages and classes included in the automated testing framework.\\n\\nThese packages and classes collectively offer a robust framework for automated testing, covering various aspects such as\\nassertion management, browser capabilities, WebDriver management, configuration handling, test reporting, logging, and\\nutilities for interaction with WebDriver and ExtentReports.\\n| Packages | Classes | Description |\\n| ------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| `com.example.assertions` | `SoftAssertionManager` | Utility class for managing soft assertions in TestNG tests. |\\n| `com.example.browserCapabilities` | `ChromeCapabilities`<br/>`EdgeCapabilities`<br/>`FirefoxCapabilities` | Provides browser capabilities for remote. execution |\\n| `com.example.browserManager` | `BrowserManager`<br/>`LocalBrowserManager`<br/>`RemoteBrowserManager` | Manages the creation of WebDriver instances based on the specified environment and browser type. |\\n| `com.example.configManager` | `ConfigFactory`<br/>`FMConfig` | Leverages Owner library interface for representing configuration properties. |\\n| `com.example.driverManager` | `DriverManager` | Manages ThreadLocal storage of WebDriver instances to initialize both local and remote WebDriver instances. |\\n| `com.example.enums` | `BrowserType`<br/>`EnvironmentType`<br/>`LocatorType` | Defines enumerations for browsers, environments, and locators. |\\n| `com.example.listeners` | `ExtentTestListener` | Listener for ExtentReports to capture test information and generate HTML reports. |\\n| `com.example.logging` | `LoggerManager` | Utility class for managing logging throughout the framework. |\\n| `com.example.reportManager` | `ExtentReportManager` | Manages the ExtentTest instances using ThreadLocal to ensure thread safety in a multi-threaded environment. |\\n| `com.example.testbuilder` | `TestBuilder` | A fluent interface for building and configuring WebDriver instances that allows customising driver initialisation, delete cookies, set timeouts etc. |\\n| `com.example.utilities` | `CommonUtil`<br/>`ExtentReportNGUtil`<br/>`StarterKit` | Offers utility methods for interacting with WebDriver and performing validations, reporting, and more.\\n\\n:::info\\nEach class within these packages contributes a significant role in the framework\'s operation.\\n:::\\n</TabItem>\\n<TabItem value=\\"arch\\" label=\\"Diagram\\">\\nBelow architectural diagram illustrates how different components interact during test execution, providing a comprehensive understanding of the framework\'s workflow.\\n![selenium-automation-framework-java](https://github.com/harryvn/selenium-automation-framework-java/assets/4848094/54cdd700-d31f-4565-b5a1-ab8cb8cdadac)\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n## Pre-requisites & Dependencies\\n\\n<Tabs>\\n    <TabItem value=\\"prereqs\\" label=\\"Pre-requisites\\">\\nBefore leveraging the selenium-automation-framework-java for automated testing, ensure the following prerequisites are met:\\n    - `Java Development Kit (JDK)`: Install the latest version of JDK to support Java development.\\n    - `Apache Maven`: Ensure Maven is installed and properly configured on your system for project build management.\\n    - `Integrated Development Environment (IDE)`: Utilise a Java IDE such as Eclipse or IntelliJ IDEA for convenient development and execution.\\n    - `Git`: Install Git, a distributed version control system, to manage the source code efficiently.\\n    </TabItem>\\n    <TabItem value=\\"deps\\" label=\\"Dependencies\\">\\nThe framework relies on the following dependencies to deliver its functionality:\\n    - `Selenium WebDriver`: A powerful web automation framework facilitating web testing across various browsers.\\n    - `TestNG`: A robust testing framework for Java applications, offering comprehensive testing capabilities.\\n    - `Owner`: A Java properties management library for streamlined configuration handling.\\n    - `SLF4J API, SLF4J Simple`: Logging facade and simple implementation for logging in Java.\\n    - `Log4j Core, Log4j API`: Logging library and API for Java, enhancing logging capabilities.\\n    - `Extent Reports`: A reporting library for test automation, providing detailed and visually appealing test reports.\\n    - `Commons IO`: Utility classes for performing I/O operations in Java.\\n    </TabItem>\\n</Tabs>\\n\\n---\\n\\n## Setup\\n\\nSetting up the selenium-automation-framework-java is straightforward:\\n\\n1. **Clone the Repository**: Clone the repository to your local machine using the provided Git clone command.\\n\\n```bash\\ngit clone https://github.com/harryvn/selenium-automation-framework-java.git\\n```\\n\\n2. **Execute the Command**: Run the provided Maven command to execute the test suite seamlessly.\\n\\n```bash\\nmvn clean test\\n```\\n\\n---\\n\\n## Test Parameters Configuration\\n\\nBelow is a dedicated section explaining how to configure various test parameters through a configuration file. The blog post includes details on the parameters, their descriptions, and example use cases demonstrating how to run tests with different configurations.\\n\\n```bash\\n### SAMPLE ###\\n# Configuration file for setting up test parameters\\nbrowser=CHROME\\nurl=https://the-internet.herokuapp.com\\nheadless=false\\nrecordVideo=false\\nremoteSeleniumGridUrl=http://localhost:4444\\nenv=REMOTE\\nusername=tomsmith\\npassword=SuperSecretPassword!\\n```\\n\\n| Parameter               | Description                                                                                                 |\\n| ----------------------- | ----------------------------------------------------------------------------------------------------------- |\\n| `browser`               | Specifies the web browser to use for testing (e.g., `CHROME`, `EDGE`, `FIREFOX`).                           |\\n| `url`                   | Defines the `URL` of the application under test, enabling seamless navigation to specific web pages.        |\\n| `headless`              | Determines whether to run the browser in headless mode, useful for executing tests without GUI interaction. |\\n| `recordVideo`           | Indicates whether to record video of the test execution, facilitating post-execution analysis and review.   |\\n| `remoteSeleniumGridUrl` | Specifies the `URL` of the remote Selenium Grid server for distributed testing.                             |\\n| `env`                   | Specifies the testing environment (e.g., `LOCAL`, `REMOTE`) to target during test execution.                |\\n| `username`              | Provides `username` for authentication.                                                                     |\\n| `password`              | Provides `password` for authentication.                                                                     |\\n| `parallel`              | Determines whether to run tests in parallel, optimising test suite execution time.                          |\\n\\n:::note\\nUsers can customise these parameters based on their testing requirements, adjusting values as necessary to tailor the testing experience.\\n:::\\n\\n### Example Use Cases\\n\\n<Tabs>\\n    <TabItem value=\\"Case1\\" label=\\"No Parameters\\">\\nExecuting Tests without Any Additional Parameters:\\n\\n```bash\\nmvn clean test\\n```\\n\\n:::info\\nTests will run with default configuration as no additional parameters are specified.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case2\\" label=\\"Browser\\">\\nLocal Testing with Chrome Browser:\\n\\n```bash\\nmvn clean test -Denv=LOCAL -Dbrowser=CHROME\\n```\\n\\n:::info\\nTests will run locally with Chrome browser and default value will be used for other parameters.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case3\\" label=\\"Video\\">\\nRemote Testing with Chrome Browser and Video Recording:\\n\\n```bash\\nmvn clean test -Denv=REMOTE -Dbrowser=CHROME -DremoteSeleniumGridUrl=<ip-address:port> -DrecordVideo=true\\n```\\n\\n:::info\\nTests will run on remote Selenium Grid with Chrome browser with video recording enabled.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case4\\" label=\\"Headless\\">\\nRemote Testing with Chrome Browser in Headless Mode:\\n\\n```bash\\nmvn clean test -Denv=REMOTE -Dbrowser=CHROME -DremoteSeleniumGridUrl=<ip-address:port> -Dheadless=true\\n```\\n\\n:::info\\nTests will run on remote Selenium Grid with Chrome browser in headless mode.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case5\\" label=\\"Auth\\">\\nAuthentication Testing with Username and Password:\\n\\n```bash\\nmvn clean test -Denv=REMOTE -Dusername=myusername -Dpassword=mypassword\\n```\\n\\n:::info\\nTests will run on remote Selenium Grid with provided username and password for authentication.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case6\\" label=\\"Parallel\\">\\nRunning Tests in Parallel:\\n\\n```bash\\nmvn clean test -Dparallel=tests\\n```\\n\\n:::info\\nTests will run in parallel reducing overall execution time.\\n:::\\n</TabItem>\\n<TabItem value=\\"Case7\\" label=\\"Dynamic URL\\">\\nSpecify Application URL for Testing:\\n\\n```bash\\nmvn clean test -Durl=<url-of-site-under-test>\\n```\\n\\n:::info\\nTests will run using the specified URL of the application under test, enabling testing across various environments (e.g., staging, production) and seamless integration with continuous integration (CI) pipelines through dynamic URL specification.\\n:::\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n## Convenient Script\\n\\nTo further streamline the testing process, the repository includes a shell script named `runTests.sh`. This script automates the execution of tests based on user inputs, offering options for browser selection, local or remote testing, Selenium Grid configuration, video recording, parallel execution, and headless mode.\\n\\n### Usage\\n\\n- Ensure the script has executable permissions:\\n\\n```bash\\nchmod +x runTests.sh\\n```\\n\\n- Users can simply run the runTests.sh script and follow the prompts to configure and execute test scenarios effortlessly.\\n\\n```bash\\n./runTests.sh\\n```\\n\\n:::info\\nThe script prompts the user to select various options and constructs the appropriate Maven command to execute the Selenium tests.\\n:::\\n\\n:::note\\nVideo recording is not supported in headless mode.\\n:::\\n\\nBelow is an example usage of the script:\\n\\n![runTests](https://github.com/harryvn/selenium-automation-framework-java/assets/4848094/62a80c39-335a-4b63-abfe-7b1b678213d5)\\n\\n:::info\\nFor a detailed explanation of each option and additional information, refer to the comments within the script itself.\\n:::\\n\\n---\\n\\n## Conclusion\\n\\nThis blog post offers a comprehensive overview of the Selenium automation framework in Java. It covers the key features, project structure, functionalities of included packages and classes, framework architecture, setup instructions, and a convenient script for test execution. By following this guide, you can gain a solid understanding of the framework and leverage it to automate your web application testing process.\\n\\nThe source code is available on [GitHub](https://github.com/harryvn/selenium-automation-framework-java/). If you find the framework helpful, be sure to star the repository to show your support!\\n\\nIn the next [article](/blog/packaging), you will learn how to update the project for packaging it into a `JAR` file, ready for execution in a containerised environment using Docker.\\n\\nTo setup and execute automation scripts on remote selenium grid refer this [article](/blog/docker).\\n\\nIf you find this article helpful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!\\n\\n---\\n\\n## References\\n\\n[Selenium](https://www.selenium.dev/)\\n\\n[TestNG](https://testng.org/)\\n\\n[ExtentReports](https://www.extentreports.com/documentation/)\\n\\n[Maven](https://maven.apache.org/guides/index.html)\\n\\n[Log4J](https://logging.apache.org/log4j/2.x/)\\n\\n[The Internet Heroku App](https://the-internet.herokuapp.com/)\\n\\n---"},{"id":"docker","metadata":{"permalink":"/automatiq-docs/blog/docker","source":"@site/blog/automation/selenium/javascript/2024-03-02-docker.md","title":"Part 3 - Docker Implementation","description":"Docker Implementation","date":"2022-12-15T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"JavaScript","permalink":"/automatiq-docs/blog/tags/javascript","description":"JavaScript tag description"},{"inline":false,"label":"PM2","permalink":"/automatiq-docs/blog/tags/pm2","description":"PM2 tag description"},{"inline":false,"label":"Docker","permalink":"/automatiq-docs/blog/tags/docker","description":"Docker tag description"}],"readingTime":7.38,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"docker","title":"Part 3 - Docker Implementation","authors":["harryvn"],"tags":["selenium","javascript","pm2","docker"],"date":"2022-12-15T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Part 1 - Selenium Automation Framework in Java","permalink":"/automatiq-docs/blog/selenium-framework-java"},"nextItem":{"title":"Part 2 - PM2 Implementation","permalink":"/automatiq-docs/blog/pm2"}},"content":"Docker Implementation\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Introduction\\n\\nIn the previous [article](/blog/pm2), we explored running the Selenium-standalone server as a detached process using `PM2`, a CLI-based manager for daemonizing application processes. Additionally, we created a configuration file to oversee various commands for starting, stopping, and disposing of `PM2` processes.\\n\\nIn this article let\'s dive deeper into exploring the potential of running automation scripts on Docker containers, including a live preview.\\n\\n---\\n\\n## Prerequisite\\n\\nBefore diving into Docker, let\'s ensure we have it set up properly. Installing Docker on your system is a prerequisite for leveraging its capabilities. Follow the official documentation [here](https://docs.docker.com/engine/install/) to install Docker according to your operating system.\\n\\n---\\n\\n## Implementation\\n\\nSeveral approaches exist for configuring the necessary Docker images to execute automated scripts. Nonetheless, in this instance, we will employ Docker\'s convenient compose file provided by the [community](https://github.com/SeleniumHQ/docker-selenium/blob/trunk/docker-compose-v3.yml). The primary aim is to demonstrate Docker\'s versatility without delving into exhaustive details beyond the scope of this discussion.\\n\\n---\\n\\n### Step 1 - Setup Selenium Grid\\n\\nLet\'s create a file `selenium-grid.yml` to define and run a Selenium Grid setup with different browser nodes (Chrome, Edge, Firefox) and a Selenium Hub.\\n\\nThe key components are as below:\\n\\n1. `version`: Specifies the version of the Docker Compose file syntax being used. In this case, it\'s version 3.\\n\\n2. `services`: Defines the services (containers) that compose the application.\\n\\n   - `chrome`, `edge`, `firefox`: These are services defining browser nodes for Chrome, Edge, and Firefox respectively. Each service is based on a specific Selenium Docker image (`selenium/node-chrome`, `selenium/node-edge`, `selenium/node-firefox`) with a particular version (`4.18.1-20240224`).\\n\\n   - `selenium-hub`: This service defines the Selenium Hub, which manages the distribution of tests across different browser nodes. It uses the `selenium/hub` Docker image with the same version as the browser nodes.\\n\\n3. `image`: Specifies the Docker image used for each service. Each browser service uses a specific Selenium node image tailored for the respective browser (Chrome, Edge, Firefox), while the Selenium Hub service uses the Selenium Hub image.\\n\\n4. `shm_size`: Defines the size of the /dev/shm shared memory space for each container. In this case, it\'s set to 2 gigabytes (`2gb`). This can be important for running browsers in containers to avoid certain issues.\\n\\n5. `depends_on`: Specifies that each browser node service depends on the Selenium Hub service. This ensures that the Selenium Hub service starts before the browser node services.\\n\\n6. `environment`: Sets environment variables for each service.\\n\\n   - `SE_EVENT_BUS_HOST`: Specifies the hostname of the event bus. All services use `selenium-hub` as the event bus host, indicating they communicate with the Selenium Hub.\\n\\n   - `SE_EVENT_BUS_PUBLISH_PORT`, `SE_EVENT_BUS_SUBSCRIBE_PORT`: Defines the ports for publishing and subscribing to events on the event bus. These are set to `4442` and `4443` respectively, matching the ports exposed by the Selenium Hub service.\\n\\n7. `ports`: Specifies the ports to expose from the Selenium Hub container to the host machine. In this case, it exposes ports `4442`, `4443`, and `4444` from the container, allowing external connections to the Selenium Hub.\\n\\nOverall, this configuration sets up a Selenium Grid with multiple browser nodes (Chrome, Edge, Firefox) connected to a central Selenium Hub, allowing for distributed testing across different browsers.\\n\\n```yaml\\nversion: \\"3\\"\\nservices:\\n  chrome:\\n    image: selenium/node-chrome:4.18.1-20240224\\n    shm_size: 2gb\\n    depends_on:\\n      - selenium-hub\\n    environment:\\n      - SE_EVENT_BUS_HOST=selenium-hub\\n      - SE_EVENT_BUS_PUBLISH_PORT=4442\\n      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443\\n\\n  edge:\\n    image: selenium/node-edge:4.18.1-20240224\\n    shm_size: 2gb\\n    depends_on:\\n      - selenium-hub\\n    environment:\\n      - SE_EVENT_BUS_HOST=selenium-hub\\n      - SE_EVENT_BUS_PUBLISH_PORT=4442\\n      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443\\n\\n  firefox:\\n    image: selenium/node-firefox:4.18.1-20240224\\n    shm_size: 2gb\\n    depends_on:\\n      - selenium-hub\\n    environment:\\n      - SE_EVENT_BUS_HOST=selenium-hub\\n      - SE_EVENT_BUS_PUBLISH_PORT=4442\\n      - SE_EVENT_BUS_SUBSCRIBE_PORT=4443\\n\\n  selenium-hub:\\n    image: selenium/hub:4.18.1-20240224\\n    container_name: selenium-hub\\n    ports:\\n      - \\"4442:4442\\"\\n      - \\"4443:4443\\"\\n      - \\"4444:4444\\"\\n```\\n\\n---\\n\\n### Step 2 - Execute `yaml` file\\n\\nNext, we\'ll initiate the containers with command `docker-compose -f selenium-grid.yml up -d`, it is used to start the services defined in the Docker Compose configuration file named `selenium-grid.yml`.\\n\\nLet\'s break down the components of this command:\\n\\n- `docker-compose`: This is the Docker Compose command-line tool used to manage multi-container Docker applications. It allows you to define and run multi-container Docker applications using YAML files.\\n\\n- `-f selenium-grid.yml`: This option specifies the path to the Docker Compose file that should be used. In this case, it\'s `selenium-grid.yml`. Using the `-f` flag allows you to specify a custom file name or path for the Docker Compose configuration file. If this flag is not used, Docker Compose looks for a file named `docker-compose.yml` by default.\\n\\n- `up`: This is a Docker Compose sub-command that is used to create and start the services defined in the Docker Compose file. It builds, (re)creates, starts, and attaches to containers for a service.\\n\\n- `-d`: This option is used to start the services in detached mode. When Docker Compose runs in detached mode, it starts the services in the background, and you can continue to use the terminal for other commands without being attached to the containers\' output.\\n\\nSo, when you run `docker-compose -f selenium-grid.yml up -d`, Docker Compose reads the `selenium-grid.yml` file, creates and starts the containers defined in that file, and runs them in the background. This command is typically used to start the Docker containers defined in the Docker Compose file as a background process.\\n\\n```bash\\ndocker-compose -f selenium-grid.yml up -d\\n```\\n\\nTo check the status of containers use command `docker compose ps`, it will list all running containers, providing information such as container ID, image used, status, and more, in our case, there should be 4 container service up and running.\\n\\n```bash\\ndocker compose ps\\n```\\n\\n<img src={require(\'@site/static/img/javascript/docker-compose.avif\').default} alt=\\"docker-compose\\" />\\n\\nOnce you navigate to the URL of the host where Selenium Grid is running, you should be able to access a dashboard displaying one node for each browser, indicating they are up and running.\\n\\n```bash\\nhttp://<selenium-grid-host-ipaddress>:4444\\n```\\n\\n<img src={require(\'@site/static/img/javascript/grid.png\').default} alt=\\"grid\\" />\\n\\n---\\n\\n### Step 3 - Execute Automation Script\\n\\nHere, we assume that the automation project is already set up. If not, you can download the source code from [GitHub](https://github.com/harryvn/automation-framework) or refer to this [article](/blog/selenium-framework-javascript) if you prefer to set up the project from scratch.\\n\\nLet\'s update the host details in the default.json file located under e2e/config. In this step, we\'ll replace localhost with the \\"hostname\\" or IP address of the system where the Docker engine is installed.\\n\\nLet\'s update the host details in the default.json file located under `e2e/config`. In this step, we\'ll replace `localhost` with the `hostname` or `IP address` of the system where the Docker engine is installed.\\n\\n:::note By default, the script will execute on Chrome browser as configured in the file. However, you have the flexibility to change it to your preferred browser, such as Firefox or Edge.\\n:::\\n\\n```json\\n{\\n  \\"url\\": \\"https://the-internet.herokuapp.com/login\\",\\n  \\"username\\": \\"tomsmith\\",\\n  \\"password\\": \\"SuperSecretPassword!\\",\\n  \\"browser\\": \\"chrome\\",\\n  \\"protocol\\": \\"http\\",\\n  \\"host\\": \\"<hostname> or <ipaddress>\\",\\n  \\"port\\": 4444\\n}\\n```\\n\\nNow, we simply execute the following command, which will automatically initiate the scripts to run on the remote Docker containers instead of the local system.\\n\\n```bash\\nnpm test\\n```\\n\\n<img src={require(\'@site/static/img/javascript/run-test.avif\').default} alt=\\"run-test\\" />\\n\\n---\\n\\n## Live Preview\\n\\nThus far, our progress has been smooth; we\'ve successfully executed the automation scripts on Docker containers.\\n\\nNext, we will explore to watch the automation execution in realtime inside Selenium Grid.\\n\\nThe selenium images are integrated with `noVNC`, enabling users to visually inspect container activity via their browser. This feature proves useful if you\'re unable to install a VNC client on your machine.\\n\\nAfter initiating the automation execution, return to the Selenium Grid interface. Under the `sessions` section, you will observe a container running. Click on the video icon associated with the container, and it will launch `noVNC`, providing a live preview of the ongoing automation execution.\\n\\n<img src={require(\'@site/static/img/javascript/live-preview.avif\').default} alt=\\"live-preview\\" />\\n\\n:::note a popup will appear requesting password. The default password is \'secret\'.\\n:::\\n\\n<img src={require(\'@site/static/img/javascript/preview.png\').default} alt=\\"preview\\" />\\n\\n---\\n\\n## Conclusion\\n\\nIn summary, this article has demonstrated the efficient use of Docker containers for running automation scripts. We established a Selenium Grid environment with multiple browser nodes connected to a central hub, enabling distributed testing.\\n\\nThe step-by-step implementation covered Docker setup, script execution, and live preview integration using noVNC. By following these procedures, users can streamline automation testing processes, enhancing efficiency and reliability in software development workflows.\\n\\nThe source code is available at [GitHub](https://github.com/harryvn/automation-framework).\\n\\nIf you find this article useful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!\\n\\n---"},{"id":"pm2","metadata":{"permalink":"/automatiq-docs/blog/pm2","source":"@site/blog/automation/selenium/javascript/2022-11-08-pm2.md","title":"Part 2 - PM2 Implementation","description":"PM2 Implementation","date":"2022-11-08T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"JavaScript","permalink":"/automatiq-docs/blog/tags/javascript","description":"JavaScript tag description"},{"inline":false,"label":"PM2","permalink":"/automatiq-docs/blog/tags/pm2","description":"PM2 tag description"}],"readingTime":2.88,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"pm2","title":"Part 2 - PM2 Implementation","authors":["harryvn"],"tags":["selenium","javascript","pm2"]},"unlisted":false,"prevItem":{"title":"Part 3 - Docker Implementation","permalink":"/automatiq-docs/blog/docker"},"nextItem":{"title":"Part 1 - Minimal Automation Framework in JavaScript","permalink":"/automatiq-docs/blog/selenium-framework-javascript"}},"content":"PM2 Implementation\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Introduction\\n\\nIn the previous [article](/blog/selenium-framework-javascript) we learned how to create a basic automation framework from scratch. We also learned to start & run a selenium-standalone server as a foreground process and terminate it manually using the escape sequence `ctrl+c`.\\n\\nIn this article, we will learn how to run the selenium-standalone server as a detached process using `PM2`.\\n\\n---\\n\\n## Implementation\\n\\n:::info PM2 is a manager to keep an application process daemonised using the CLI, if you want to know more check [here](https://pm2.io/).\\n:::\\n\\n### Step 1 - Install Dependency\\n\\n```bash\\nnpm i -g pm2\\n```\\n\\n:::note installing PM2 as a global dependency is recommended.\\n:::\\n\\n---\\n\\n### Step 2 - Configuration\\n\\nLet\'s create a file `ecosystem.config.js` at the project root as recommended in [PM2](https://pm2.keymetrics.io/docs/usage/application-declaration/) documentation.\\n\\n```bash\\npm2 init simple\\n```\\n\\n```js\\nmodule.exports = {\\n  apps: [\\n    {\\n      name: \\"standalone-server\\",\\n      script: \\"./app.js\\",\\n    },\\n  ],\\n};\\n```\\n\\nNext, we will create an `app.js` file at the project root.\\n\\n:::note we will be using NodeJS \\"child_process\\" to execute npm commands.\\n:::\\n\\n```js\\nconst { exec } = require(\\"child_process\\");\\nexec(\\"npm run setup && npm start\\");\\n```\\n\\n:::note here we are running the \\"setup\\" first to ensure the browser driver dependencies are installed before starting the server.\\n:::\\n\\n---\\n\\n### Step 3 - Start Server\\n\\nLet\'s now start the selenium-standalone server as a daemonised process.\\n\\n```bash\\npm2 start ecosystem.config.js\\n```\\n\\n![image](https://user-images.githubusercontent.com/4848094/194100702-7b07638b-f214-4f3b-b063-41b49b7b7dc2.png)\\n\\n:::note the above command will start the selenium server in the background, you can access it at `http://localhost:4444`.\\n:::\\n\\n![image](https://user-images.githubusercontent.com/4848094/194100940-1c9d9619-5f7c-4cd6-920a-5e4722a07e3b.png)\\n\\n---\\n\\n### Step 4 - Run Tests\\n\\nLet\'s execute the test cases.\\n\\n```bash\\nnpm test\\n```\\n\\n---\\n\\n### Step 5 - Stop Server\\n\\nOnce the test cases are executed and there are no more tests to run, we can stop the server process.\\n\\n:::note the stopped process can be started anytime as mentioned in Step 3.\\n:::\\n\\n```bash\\npm2 stop ecosystem.config.js\\n```\\n\\n![image](https://user-images.githubusercontent.com/4848094/194101095-80773421-6e98-4910-b3d1-2b360406466f.png)\\n\\n---\\n\\n### Step 6 - Dispose Server\\n\\nWe can also delete the server process at any point in time.\\n\\n```bash\\npm2 delete ecosystem.config.js\\n```\\n\\n![image](https://user-images.githubusercontent.com/4848094/194101205-d480d094-bc35-4059-85f7-a8f0a892e119.png)\\n\\n---\\n\\n## Logs\\n\\nBy default, PM2 stores two types of logs as below\\n\\n- global logs at `$HOME/.pm2/pm2.log`\\n\\n- application logs at `$HOME/.pm2/logs/`\\n\\nTo display all the logs in realtime, run the following command.\\n\\n```bash\\npm2 logs\\n```\\n\\n<img src={require(\'@site/static/img/javascript/all-logs.avif\').default} alt=\\"all-logs\\" />\\n\\nTo display application logs, run the following command.\\n\\n```bash\\npm2 logs selenium-standalone\\n```\\n\\n<img src={require(\'@site/static/img/javascript/app-logs.avif\').default} alt=\\"app-logs\\" />\\n\\n---\\n\\n## Monitoring\\n\\nWe can also monitor the application logs using the below command.\\n\\n```bash\\npm2 monit\\n```\\n\\n<img src={require(\'@site/static/img/javascript/monit.avif\').default} alt=\\"monit\\" />\\n\\n:::note The above image is just a sample.\\n:::\\n\\n---\\n\\n## Conclusion\\n\\nSo far, we learned how to create a bare minimum automation framework from scratch, we also learned how to daemonize the selenium-standalone server to run as a background process on a standalone operating system.\\n\\nIn the next [article](/blog/docker), we will learn to execute the automation scripts on docker containers, a live preview and much more in action.\\n\\nThe source code is available at [GitHub](https://github.com/harryvn/automation-framework).\\n\\nIf you find this article useful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!"},{"id":"selenium-framework-javascript","metadata":{"permalink":"/automatiq-docs/blog/selenium-framework-javascript","source":"@site/blog/automation/selenium/javascript/2022-09-10-framework.md","title":"Part 1 - Minimal Automation Framework in JavaScript","description":"A bare minimum automation framework","date":"2022-09-10T00:00:00.000Z","tags":[{"inline":false,"label":"Selenium","permalink":"/automatiq-docs/blog/tags/selenium","description":"Selenium tag description"},{"inline":false,"label":"JavaScript","permalink":"/automatiq-docs/blog/tags/javascript","description":"JavaScript tag description"},{"inline":false,"label":"Mocha","permalink":"/automatiq-docs/blog/tags/mocha","description":"Mocha tag description"},{"inline":false,"label":"Chai","permalink":"/automatiq-docs/blog/tags/chai","description":"Chai tag description"},{"inline":false,"label":"Winston","permalink":"/automatiq-docs/blog/tags/winston","description":"Winston tag description"}],"readingTime":7.66,"hasTruncateMarker":true,"authors":[{"name":"Hari Nair","title":"Test Architect","url":"https://github.com/harryvn","page":{"permalink":"/automatiq-docs/blog/authors/harryvn"},"socials":{"github":"https://github.com/harryvn","linkedin":"https://www.linkedin.com/in/harryvn/"},"imageURL":"https://github.com/harryvn.png","key":"harryvn"}],"frontMatter":{"slug":"selenium-framework-javascript","title":"Part 1 - Minimal Automation Framework in JavaScript","authors":["harryvn"],"tags":["selenium","javascript","mocha","chai","winston"]},"unlisted":false,"prevItem":{"title":"Part 2 - PM2 Implementation","permalink":"/automatiq-docs/blog/pm2"}},"content":"A bare minimum automation framework\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Introduction\\n\\nThis article will provide a high-level overview of creating the framework from scratch. It explains how to set up the project and the tools needed to make the framework as effective as possible.\\n\\n---\\n\\n## Prerequisites\\n\\nThis framework depends on the following tools and concepts.\\n\\n1. **Visual Studio Code** (or any IDE of your choice)\\n\\n2. **NodeJS**\\n\\n3. **NPM**\\n\\n4. **Selenium WebDriver**\\n\\n---\\n\\n## Structure\\n\\nAny framework you design should be organized for better maintenance.\\n\\nIt is important to understand the overall project structure, below is the folder structure of this project.\\n\\n- `config` - all configurations will reside here\\n\\n- `logs` - store all types of logs\\n\\n- `reports` - reports are saved here\\n\\n- `pages` - to store locators and other details using the page object design\\n\\n- `specs` - contains test cases\\n\\n- `utils` - all global scripts\\n\\n- `data` - to store all relevant test data (optional in our case)\\n\\nA typical project structure is as below.\\n\\n<img src={require(\'@site/static/img/javascript/project-structure.avif\').default} alt=\\"project-structure\\" />\\n\\n---\\n\\n## Implementation\\n\\nFollowing is the implementation of the framework.\\n\\n<Tabs>\\n    <TabItem value=\\"prereqs\\" label=\\"Initialise Project\\">\\nCreate a project directory and open it with an IDE.\\n\\n```bash\\nmkdir e2e && cd e2e && code .\\n```\\n\\nWe will be using `npm` as the default package manager. So, let\'s initialize the project root.\\n\\n```bash\\nnpm init -y\\n```\\n\\nThe `-y` flag will initialize and create a `package.json` file with default values as below.\\n\\n```json\\n{\\n  \\"name\\": \\"e2e\\",\\n  \\"version\\": \\"1.0.0\\",\\n  \\"description\\": \\"\\",\\n  \\"main\\": \\"index.js\\",\\n  \\"scripts\\": {\\n    \\"test\\": \\"echo \\\\\\"Error: no test specified\\\\\\" && exit 1\\"\\n  },\\n  \\"keywords\\": [],\\n  \\"author\\": \\"\\",\\n  \\"license\\": \\"ISC\\"\\n}\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"install\\" label=\\"Install Dependencies\\">\\nInstall the following dependencies.\\n\\n```bash\\nnpm install selenium-webdriver selenium-standalone winston config chai mocha mochawesome\\n```\\n\\nIt will include all packages as a project dependency in the `package.json` file.\\n\\n```json\\n\\"dependencies\\": {\\n    \\"chai\\": \\"^4.3.6\\",\\n    \\"config\\": \\"^3.3.7\\",\\n    \\"mocha\\": \\"^10.0.0\\",\\n    \\"mochawesome\\": \\"^7.1.3\\",\\n    \\"selenium-standalone\\": \\"^8.2.0\\",\\n    \\"selenium-webdriver\\": \\"^4.4.0\\",\\n    \\"winston\\": \\"^3.8.1\\"\\n  }\\n```\\n\\n- `chai` - an assertion library\\n\\n- `config` - to handle global configurations\\n\\n- `mocha` - test framework\\n\\n- `mochawesome` - custom reporter in combination with the test framework\\n\\n- `selenium-standalone` - NodeJS based cli for launching selenium server\\n\\n- `selenium-webdriver` - browser automation library\\n\\n- `winston` - logger to write custom logs\\n\\n</TabItem>\\n\\n<TabItem value=\\"init\\" label=\\"Create Directories\\">\\nLet\'s create the required folders.\\n\\n```bash\\nmkdir -p config pages specs utils logs reports\\n```\\n\\n</TabItem>\\n\\n</Tabs>\\n\\n---\\n\\n## Start Scripting\\n\\n### Utils\\n\\nThis directory will store generic scripts used globally.\\n\\nSo, under `utils` create the following files.\\n\\n- `driver.js` to initialize the \\"driver\\" as a global variable.\\n\\n- `logger.js` file to generate logs.\\n\\n- `common.js` file for handling selenium methods using generic functions.\\n\\n- `startup.js` under the utils folder to handle browser & driver sessions.\\n\\n:::note\\nTest cases will evolve over time. So, as a best practice, we should initialize and quit the browser sessions once per every test case or once per group of test cases.\\n:::\\n\\n:::info\\nDynamic variables are used to read data from the config file instead of hardcoded values.\\n:::\\n\\n<Tabs>\\n<TabItem value=\\"driver\\" label=\\"driver.js\\">\\n\\n```js\\nconst { Builder } = require(\\"selenium-webdriver\\");\\nconst log = require(\\"./logger\\");\\nconst config = require(\\"config\\");\\n\\nconst browser = process.env.BROWSER || config.get(\\"browser\\");\\nconst protocol = process.env.PROTOCOL || config.get(\\"protocol\\");\\nconst host = process.env.HOST || config.get(\\"host\\");\\nconst port = process.env.PORT || config.get(\\"port\\");\\nconst seleniumAddress =\\n  process.env.seleniumAddress || `${protocol}://${host}:${port}`;\\n\\nlet driver = new Builder()\\n  .forBrowser(browser)\\n  .usingServer(seleniumAddress)\\n  .build();\\n\\nclass Driver {\\n  constructor() {\\n    global.driver = driver;\\n    log.info(\\"Driver has Initialized\\");\\n    log.info(`Opening ${browser} browser`);\\n  }\\n}\\n\\nmodule.exports = new Driver();\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"logger\\" label=\\"logger.js\\">\\n\\n```js\\nconst { createLogger, format, transports } = require(\\"winston\\");\\nconst { combine, timestamp, printf, colorize } = format;\\n\\nconst logFormat = printf(({ message, timestamp }) => {\\n  return `${timestamp} => ${message}`;\\n});\\n\\nconst logger = createLogger({\\n  format: combine(\\n    colorize(),\\n    timestamp({ format: \\"YYYY-MM-DD HH:mm:ss\\" }),\\n    logFormat\\n  ),\\n  transports: [new transports.File({ filename: \\"./logs/automation.log\\" })],\\n});\\n\\nmodule.exports = logger;\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"common\\" label=\\"common.js\\">\\n\\n```js\\nrequire(\\"./driver\\");\\nrequire(\\"chai\\").should();\\nconst { By, Key, until } = require(\\"selenium-webdriver\\");\\nconst config = require(\\"config\\");\\nconst log = require(\\"./logger\\");\\nconst env = process.env.NODE_ENV || \\"prod\\";\\n\\nconst baseURL = config.get(\\"url\\");\\n\\nclass Common {\\n  async getURL() {\\n    await driver.get(baseURL);\\n    log.info(`The test will run on ${env} environment`);\\n    log.info(`The url is: ${baseURL}`);\\n  }\\n\\n  async setImplicitWait() {\\n    await driver.manage().setTimeouts({ implicit: 10000 });\\n    log.info(\\"Set Implicit Wait Globally\\");\\n  }\\n\\n  async getMaximizeWindow() {\\n    await driver.manage().window().maximize();\\n    log.info(\\"Browser window maximized\\");\\n  }\\n\\n  async getDeleteAllCookies() {\\n    await driver.manage().deleteAllCookies();\\n    log.info(\\"Deleted Browser Cookies\\");\\n  }\\n\\n  async getWindowTitle(windowTitle) {\\n    let title = await driver.getTitle().then(function (value) {\\n      return value;\\n    });\\n\\n    await title.should.equal(windowTitle);\\n    log.info(`The title on browser window is ${windowTitle}`);\\n  }\\n\\n  async getElementLocator(locator, locatorType) {\\n    let element = null;\\n    let timer = 30000;\\n    if (locatorType === \\"id\\") {\\n      element = await driver.wait(until.elementLocated(By.id(locator)), timer);\\n    } else if (locatorType === \\"xpath\\") {\\n      element = await driver.wait(\\n        until.elementLocated(By.xpath(locator)),\\n        timer\\n      );\\n    } else if (locatorType === \\"name\\") {\\n      element = await driver.wait(\\n        until.elementLocated(By.name(locator)),\\n        timer\\n      );\\n    } else if (locatorType === \\"css\\") {\\n      element = await driver.wait(until.elementLocated(By.css(locator)), timer);\\n    } else if (locatorType === \\"linkText\\") {\\n      element = await driver.wait(\\n        until.elementLocated(By.linkText(locator)),\\n        timer\\n      );\\n    } else if (locatorType === \\"partialLinkText\\") {\\n      element = await driver.wait(\\n        until.elementLocated(By.partialLinkText(locator)),\\n        timer\\n      );\\n    }\\n    return element;\\n  }\\n\\n  async getSendKeys(locator, locatorType, locatorName, sendValue) {\\n    let element = await this.getElementLocator(locator, locatorType);\\n    if (element.isDisplayed()) {\\n      await element.clear();\\n      await element.sendKeys(sendValue);\\n      log.info(`Entered value into ${locatorName}`);\\n    } else {\\n      log.error(`${locatorName} not found`);\\n    }\\n  }\\n\\n  async getClick(locator, locatorType, locatorName) {\\n    let element = await this.getElementLocator(locator, locatorType);\\n    if (element.isEnabled()) {\\n      await element.click();\\n      log.info(`Clicked ${locatorName}`);\\n    } else {\\n      log.error(`${locatorName} is disabled`);\\n    }\\n  }\\n\\n  async getQuitBrowser() {\\n    await driver.quit();\\n    log.info(\\"Browser Closed\\");\\n  }\\n}\\n\\nmodule.exports = new Common();\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"startup\\" label=\\"startup.js\\">\\n\\n```js\\nconst common = require(\\"./common\\");\\n\\nbefore(async () => {\\n  await common.getMaximizeWindow();\\n  await common.getDeleteAllCookies();\\n  await common.getURL();\\n  await common.setImplicitWait();\\n});\\n\\nafter(async () => {\\n  await common.getQuitBrowser();\\n});\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n### Pages\\n\\nNext, let\'s extend the `utils` capabilities to design our page objects.\\n\\nThe pages in scope are Login & Logout features. So, create two files, `loginPage.js` & `logoutPage.js` under `pages` directory.\\n\\n<Tabs>\\n\\n<TabItem value=\\"loginPage\\" label=\\"loginPage.js\\">\\n\\n```js\\nconst common = require(\\"../utils/common\\");\\nconst config = require(\\"config\\");\\n\\nconst username = config.get(\\"username\\");\\nconst password = config.get(\\"password\\");\\n\\nconst USERNAME = \\"username\\";\\nconst PASSWORD = \\"password\\";\\nconst LOGIN = \\"//form/button[@type=\'submit\']\\";\\n\\nclass LoginPage {\\n  async loginToApp() {\\n    await common.getSendKeys(USERNAME, \\"id\\", \\"username textbox\\", username);\\n    await common.getSendKeys(PASSWORD, \\"id\\", \\"password textbox\\", password);\\n    await common.getClick(LOGIN, \\"xpath\\", \\"login button\\");\\n  }\\n}\\n\\nmodule.exports = new LoginPage();\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"logoutPage\\" label=\\"logoutPage.js\\">\\n\\n```js\\nconst common = require(\\"../utils/common\\");\\n\\nconst LOGOUT = \\"//div[@class=\'example\']/a\\";\\n\\nclass LogoutPage {\\n  async logoutFromApp() {\\n    await common.getClick(LOGOUT, \\"xpath\\", \\"logout button\\");\\n  }\\n}\\n\\nmodule.exports = new LogoutPage();\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n### Specs\\n\\nFinally, it is time to write test cases using the page object logic.\\n\\nWe will create two test cases, `loginSpec.js` & `logoutSpec.js` under `specs` directory.\\n\\n<Tabs>\\n\\n<TabItem value=\\"loginSpec\\" label=\\"loginSpec.js\\">\\n\\n```js\\nconst common = require(\\"../utils/common\\");\\nconst loginPage = require(\\"../pages/loginPage\\");\\nrequire(\\"../utils/startup\\");\\n\\ndescribe(\\"title test\\", function () {\\n  it(\\"verify the title on login page\\", async function () {\\n    await common.getWindowTitle(\\"The Internet\\");\\n  });\\n});\\n\\ndescribe(\\"login Test\\", function () {\\n  it(\\"verify user is logged in successfully!\\", async function () {\\n    await loginPage.loginToApp();\\n  });\\n});\\n```\\n\\n</TabItem>\\n\\n<TabItem value=\\"logoutSpec\\" label=\\"logoutSpect.js\\">\\n\\n```js\\nconst logoutpage = require(\\"../pages/logoutPage\\");\\nrequire(\\"../utils/startup\\");\\n\\ndescribe(\\"logout test\\", function () {\\n  it(\\"verify user is logged out successfully!\\", async function () {\\n    await logoutpage.logoutFromApp();\\n  });\\n});\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\n### Config\\n\\nCreate a file `default.json` under the `config` directory.\\n\\n:::note\\nA sample login page is used in this framework, for more details refer [here](https://github.com/saucelabs/the-internet).\\n:::\\n\\n```json\\n{\\n  \\"url\\": \\"https://the-internet.herokuapp.com/login\\",\\n  \\"username\\": \\"tomsmith\\",\\n  \\"password\\": \\"SuperSecretPassword!\\",\\n  \\"browser\\": \\"chrome\\",\\n  \\"protocol\\": \\"http\\",\\n  \\"host\\": \\"localhost\\",\\n  \\"port\\": 4444\\n}\\n```\\n\\n---\\n\\n### Additional Configs\\n\\nNext, we are using `mocha` as the test framework, add a `conf.js` file at the project root.\\n\\n:::info\\nThis framework supports parallel execution, it is set to false as the test cases are limited.\\n:::\\n\\n```json\\nmodule.exports = {\\n  timeouts: 60000,\\n  exit: true,\\n  bail: true,\\n  slow: 1000,\\n  recursive: true,\\n  parallel: false,\\n\\n  spec: [\\"./specs/loginSpec.js\\", \\"./specs/logoutSpec.js\\"],\\n\\n  reporter: \\"mochawesome\\",\\n  require: \\"mochawesome/register\\",\\n  reporterOption: [\\n    \\"reportDir=reports\\",\\n    \\"reportTitle=Automation Report\\",\\n    \\"reportFilename=report\\",\\n  ],\\n};\\n```\\n\\nIt\'s time for execution, but before that, we need to handle some prerequisites in the `scripts` section under the `package.json` file.\\n\\n```json\\n\\"scripts\\": {\\n    \\"setup\\": \\"selenium-standalone install > ./logs/driver.log &\\",\\n    \\"start\\": \\"selenium-standalone start > ./logs/server.log &\\",\\n    \\"test\\": \\"mocha --config conf.js\\"\\n  },\\n```\\n\\n---\\n\\n## Execute Tests\\n\\nWe need to do ensure all pre-requisites are in place before running the tests.\\n\\n<Tabs>\\n\\n<TabItem value=\\"setup\\" label=\\"Download Browser Drivers\\">\\n\\n```bash\\nnpm run setup\\n```\\n\\n![npm-run-setup](https://user-images.githubusercontent.com/4848094/189416696-dff14c4b-608e-45ab-bee2-734adec165d4.gif)\\n\\n</TabItem>\\n\\n<TabItem value=\\"start\\" label=\\"Start Selenium Standalone Server\\">\\n\\n```bash\\nnpm start\\n```\\n\\n![npm-start](https://user-images.githubusercontent.com/4848094/189416764-68277dd1-1142-48da-84d0-3bd418742def.gif)\\n\\n:::note\\nThe server process will run in the foreground.\\n:::\\n\\n</TabItem>\\n\\n<TabItem value=\\"run\\" label=\\"Run Tests\\">\\n\\n```bash\\nnpm test\\n```\\n\\nThe above command will:\\n\\n- open browser\\n\\n- execute test cases\\n\\n- generate HTML report\\n\\nBelow is an example of the test execution and results.\\n\\n#### Console Output\\n\\n![npm-test](https://user-images.githubusercontent.com/4848094/189416927-8dbafdde-3698-445b-aae9-7cda3e7af06b.gif)\\n\\n#### Test Execution in Progress\\n\\n![npm-test-running](https://user-images.githubusercontent.com/4848094/189417641-1ea9698c-fdd7-419a-9d22-c2f840c3c6e9.gif)\\n\\n#### HTML Report\\n\\n![report](https://user-images.githubusercontent.com/4848094/189417711-ed52fdc8-2b23-4236-b5a5-fdb9ca034d4c.jpg)\\n\\n</TabItem>\\n</Tabs>\\n\\n---\\n\\nAs a best practice, we should persist all logs for reference. So, we will write it to multiple files under the logs directory.\\n\\n<img src={require(\'@site/static/img/javascript/logs-folder.avif\').default} alt=\\"logs-folder\\" />\\n\\n---\\n\\n## Conclusion\\n\\nThe selenium-standalone server runs in the foreground and holds the `TTY` till it\'s terminated manually.\\n\\nThere are several solutions, one of them being `PM2` to run the process in the background, which we will discuss in [Part 2](/blog/pm2).\\n\\nThe source code is available at [GitHub](https://github.com/harryvn/automation-framework).\\n\\nIf you find this article useful or have any suggestions, reach out to me on [LinkedIn](https://www.linkedin.com/in/harryvn/).\\n\\nThank you and keep learning!\\n\\n---"}]}}')}}]);